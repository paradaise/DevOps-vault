##### ___Процесс___ - это исполняемая программа + её контекст

##### Каждый процесс представлен структурой - `task_struct`
##### Структура занимает около 6Кб и в ней записана основная информация по процессу
#### Основные поля в структуре:

- __PID__ - уникальный идентификатор процесса, появляется при его создании.
- __TGID__ - общий идентификатор для каждого процесса в потоке. 
- __ММ__ - указатель на структуру памяти процесса.
- __FILES__ - таблица открытых файлов.( Первые 3 STDIN,STDOUT,STDERR всегда заняты)
- __SIGNAL__ - обработчик сигналов
- __PARENT,CHILDREN__ - информация о процессе родителе и дочерних процессах
![[code_example.png]]
##### Пример кода такой структуры на C

- Каждый процесс имеет:
    
    - **PID** (Process ID) — уникальный идентификатор.
        
    - **PPID** (Parent PID) — PID родительского процесса.
        
    - Состояние (`Running`, `Sleeping`, `Stopped`, `Zombie`).
        
    - Виртуальное адресное пространство (память, файловые дескрипторы).


##### Все процессы хранятся в `хеш-таблице` для быстрого поиска процесса по PID
##### Максимальное кол-во PID - `32768`  задается в файле: `/proc/sys/kernel/pid_max`
##### __Если PID закончились__ - система начинает их циклическое переиспользование, за это отвечает функция - `ALLOC_PID()` и она использует битовую карту для отслеживания занятых PID

## **2. Системные вызовы для работы с процессами**

| Вызов                  | Описание                                                         |
| ---------------------- | ---------------------------------------------------------------- |
| `fork()`               | Создает копию процесса (дочерний процесс).                       |
| `exec()`               | Заменяет текущий процесс новой программой.                       |
| `exit()`               | Завершает процесс (но остается запись в таблице процессов).      |
| `wait()` / `waitpid()` | Родитель ждет завершения дочернего процесса и читает его статус. |
| `getpid()`             | Возвращает PID текущего процесса.                                |
| `getppid()`            | Возвращает PPID (родительский PID).                              |

### Рождение процессов
##### Новые процессы рождаются только от других процессов, за то чтобы это было возможно отвечает системный вызов `fork()`
##### Работает как клонирование, родительский процесс создает точную копию себя.
#### Алгоритм:
- Копируется tusk_struct родителя;
- Создается новый PID;
- Настраиваются связи parrent-child;

При этом память не копируются сразу, а используется технология `copy-on-write`
В чем суть: сразу после `fork()` оба процесса используют одни и те же физические страницы памяти, один экземпляр, но как только один процесс пытается что-то изменить в памяти, срабатывает ловушка, ОС перехватывает эту попытку, создает копию нужной страницы, и только после этого совершает запись

![[process_fork.png]]

##### Кроме `fork()` есть системный вызов `clone()`
##### `сlone()` - позволяет более тонко настроить что будет общего между родителем и потомком, fork() - lite, clone() - pro
#### __Прародитель всех процессов__ - системы инициализации init(старые) или systemd(новые системы)


### Cмерть процесса

#### Типы завершения процесса:
- Нормальное - return() из функции main или вызов exit()
- Получение смертельного сигнала - sigkill
- Необработанное исключение

#### Функция `do_exit()` в ядре оркеструет умирание процесса:
- Устанавливается флаг `pf_exiting` - процесс помечается как умиравший;
- Освобождаются все удерживаемые ресурсы, закрываются все открытые файлы, уменьшаются счетчики ссылок;
- Если умирающий процесс был последним кто использовал файл - то файл действительно закрывается;
- Освобождается память;
- Все дети процесса передаются `init` или `subruper`(управленец systemd для сирот).

#### Но на самом деле процесс не исчез полностью, он переходит в состояние `exit-zombie`
	От него остается Task Struct с минимальной информацией: 
	- Pid 
	- Код завершения
	- Статистика использования ресурсов

Это нужно чтобы родитель узнал как завершился ребенок, и пока процесс-родитель не вызовет `wait()` - зомби будет существовать.

	Когда родитель вызовет `wait()`:
- Ядро найдет зомби-процесс;
- Копирует код завершения родителю;
- Освободит `Task Struct`;
- Удалит процесс из всех списков;
- Освободит `PID` для его повторного использования.


#### Концепция `supreaper` - в системах systemd, это процессы которые могут усыновлять сирот вместо init

### Межпроцессорное взаимодействие

__Процессы__ - изолированы друг от друга, но иногда им нужно общаться, есть основные способы взаимодействия:
 - __Разделяемая память__ - самый быстрый способ, фрагмент памяти куда имеют доступ несколько процессов, не нужно копировать данные, обращаться к ядру, один написал в память, другой сразу видит, однако требует __синхронизации__;
 - __Пайпы__ - однонаправленная труба для передачи данных, есть вход и выход, один процесс пишет на вход, другой читает на выходе. Технически для каждого пайпа в ядре создается `кольцевой буфер` размером 64Кб, если буфер полный - процесс писателя ждет пока он очистится, если буфер пустой - то блокируется читатель, происходит;
 - Сигналы - это короткие сообщения которые один процесс может послать другому, у каждого процесса есть таблица обработчиков сигнала, там расписано что делать при получении каждого типа сигнала. За передачу сигнала от процесса к процессу - отвечает __ядро__;
 - Сокеты - двунаправленные каналы связи, которые работают в приделах одной машины, внутренняя сеть, в отличии от пайпа позволяет вести полноценный диалог - оба участника могут как и отправлять данные, так и забирать их. 


### Изоляция процессов

#### За изоляцию процессов отвечает - `namespaces(пространство имен)`, он позволяет сделать иллюзию что процесс один в системе.

Виды namespaces:
- PID Namespaces ( своя нумерация процессов);
- Network Namespaces ( изолированный сетевой стек, с собственными интерфейсами, таблицами маршрутизации, правилами firewall  и так далее);
- Mount Namespace ( приватные точки монтирования, процесс может видеть совсем другую файловую систему)
- User Namespace ( процесс может быть root внутри своего namespace, но другим пользователем снаружи его)

#### Еще один принцип изоляции - это Cgroup(квоты и лимиты)

Cgroups позволяют ограничивать ресурсы для групп процессов, например:
- Ограничение процессорного времени
- Ограничение по памяти( прилетает OOM киллер и убивает самый прожорливый процесс в группе)
- Ограничение дискового ввода/вывода(blkio)
- Ограничение максимального кол-ва процессов в группе(PID)
![[cgroups.png]]


## **Сироты (Orphan Processes)**

- **Когда появляются?**
    
    - Родитель завершился раньше дочернего процесса (`exit()` без `wait()`).
        
- **Что происходит?**
    
    - Дочерний процесс **усыновляется `init` (PID=1)**.
        
    - `init` периодически вызывает `wait()`, чтобы собрать статус.
        

---

## **Зомби (Zombie Processes)**

- **Когда появляются?**
    
    - Дочерний процесс завершился (`exit()`), но родитель **не вызвал `wait()`**.
        
- **Чем опасны?**
    
    - Занимают запись в таблице процессов (но не потребляют CPU/RAM).
        
    - Если зомби много → не хватает PIDs (`pid_max`).
        
- **Как убить?**
    
    - Заставить родителя вызвать `wait()`.
        
    - Если родитель "повис" → убить его (`kill -9 PPID`), тогда зомби усыновит `init` и очистится.
        

---

## **5. Просмотр процессов**

bash

Copy

Download

ps aux       # Список всех процессов  
top/htop     # Интерактивный мониторинг  
pstree       # Дерево процессов  
lsof -p PID  # Открытые файлы процесса  

---

### **Key Takeaways**

✅ **`fork()` + `exec()` = запуск новой программы.**  
✅ **Родитель должен `wait()`, иначе зомби.**  
✅ **Сироты наследует `init`.**  
✅ **Зомби не потребляют ресурсы, но занимают PID.**