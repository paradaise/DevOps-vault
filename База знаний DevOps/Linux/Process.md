##### ___Процесс___ - это исполняемая программа + её контекст

##### Каждый процесс представлен структурой - `task_struct`
##### Структура занимает около 6Кб и в ней записана основная информация по процессу
#### Основные поля в структуре:

- __PID__ - уникальный идентификатор процесса, появляется при его создании.
- __TGID__ - общий идентификатор для каждого процесса в потоке. 
- __ММ__ - указатель на структуру памяти процесса.
- __FILES__ - таблица открытых файлов.( Первые 3 STDIN,STDOUT,STDERR всегда заняты)
- __SIGNAL__ - обработчик сигналов
- __PARENT,CHILDREN__ - информация о процессе родителе и дочерних процессах
![[code_example.png]]
##### Пример кода такой структуры на C


##### Все процессы хранятся в `хеш-таблице` для быстрого поиска процесса по PID
##### Максимальное кол-во PID - `32768`  задается в файле: `/proc/sys/kernel/pid_max`
##### __Если PID закончились__ - система начинает их циклическое переиспользование, за это отвечает функция - `ALLOC_PID()` и она использует битовую карту для отслеживания занятых PID



### Рождение процессов
##### Новые процессы рождаются только от других процессов, за то чтобы это было возможно отвечает системный вызов `fork()`
##### Работает как клонирование, родительский процесс создает точную копию себя.
#### Алгоритм:
- Копируется tusk_struct родителя;
- Создается новый PID;
- Настраиваются связи parrent-child;

При этом память не копируются сразу, а используется технология `copy-on-write`
В чем суть: сразу после `fork()` оба процесса используют одни и те же физические страницы памяти, один экземпляр, но как только один процесс пытается что-то изменить в памяти, срабатывает ловушка, ОС перехватывает эту попытку, создает копию нужной страницы, и только после этого совершает запись

![[process_fork.png]]

##### Кроме `fork()` есть системный вызов `clone()`
##### `сlone()` - позволяет более тонко настроить что будет общего между родителем и потомком, fork() - lite, clone() - pro
#### __Прародитель всех процессов__ - системы инициализации init(старые) или systemd(новые системы)


### Cмерть процесса

#### Типы завершения процесса:
- Нормальное - return() из функции main или вызов exit()
- Получение смертельного сигнала - sigkill
- Необработанное исключение

#### Функция `do exit()` в ядре оркеструет умирание процесса:
- Устанавливается флаг `pf_exiting` - процесс помечается как умиравший;
- Освобождаются все удерживаемые ресурсы, закрываются все открытые файлы, уменьшаются счетчики ссылок;
- Если умирающий процесс был последним кто использовал файл - то файл действительно закрывается;
- Освобождается память;
- Все дети процесса передаются `init` или `subruper`(управленец systemd для сирот)

#### Но на самом деле процесс не исчез полностью, он переходит в состояние `exit-zombie`
	От него остается Task Struct с минимальной информацией: 
	- Pid 
	- Код завершения
	- Статистика использования ресурсов

Это нужно чтобы родитель узнал как завершился ребенок, и пока процесс-родитель не вызовет `wait()` - зомби будет существовать.

	Когда родитель вызовет `wait()`:
- Ядро найдет зомби-процесс;
- Копирует код завершения родителю;
- Освободит `Task Struct`;
- Удалит процесс из всех списков;
- Освободит `PID` для его повторного использования.